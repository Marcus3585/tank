<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 坦克 Online (雙重偵測版)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: "Segoe UI", sans-serif; user-select: none; color: white; }
        #canvas-container { position: absolute; width: 100%; height: 100vh; z-index: 1; }
        .input_video { display: none; }
        
        #output_canvas { 
            position: absolute; top: 20px; right: 20px; width: 320px; height: 240px; 
            z-index: 2; border: 2px solid #00ffff; border-radius: 10px; background: rgba(0,0,0,0.6); transform: scaleX(-1); 
        }
        #hp-bar { position: absolute; top: 20px; left: 20px; z-index: 5; font-size: 24px; text-shadow: 2px 2px 0 #000; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0,0,0,0.85); pointer-events: auto; transition: opacity 0.5s;
        }
        .panel { 
            background: rgba(0, 20, 40, 0.9); border: 2px solid #00ffff; padding: 40px; 
            border-radius: 15px; text-align: center; box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
            max-width: 500px;
        }
        h1 { margin: 0 0 20px 0; color: #00ffff; text-transform: uppercase; letter-spacing: 2px; }
        p { color: #aaa; margin-bottom: 30px; font-size: 18px; }
        .status { font-size: 20px; font-weight: bold; margin-bottom: 20px; min-height: 30px; color: #ffcc00; }
        
        button {
            background: #00ffff; color: #000; border: none; padding: 15px 40px;
            font-size: 20px; font-weight: bold; cursor: pointer; border-radius: 5px;
            transition: 0.2s; text-transform: uppercase;
        }
        button:hover { background: #fff; box-shadow: 0 0 15px #00ffff; }
        button:disabled { background: #555; color: #888; cursor: not-allowed; box-shadow: none; }

        #settings-panel { position: absolute; top: 280px; right: 20px; z-index: 5; display: flex; flex-direction: column; gap: 5px; }
        .btn-sm { background: rgba(0,255,255,0.2); border: 1px solid #0ff; color: #fff; padding: 5px 10px; cursor: pointer; }
        .btn-sm.active { background: #0ff; color: #000; }
        
        #damage-overlay { position: absolute; width: 100%; height: 100%; background: red; opacity: 0; pointer-events: none; z-index: 4; transition: opacity 0.1s; }
        #debug-info { position: absolute; bottom: 10px; right: 20px; color: #00ff00; font-family: monospace; font-size: 12px; z-index: 5; text-align: right; }
    </style>
</head>
<body>

<div id="damage-overlay"></div>
<div id="debug-info">系統初始化中...</div>

<div id="ui-layer">
    <div class="panel" id="lobby-panel">
        <h1>Tank Battle Online</h1>
        <p>手勢操控多人對戰系統</p>
        <div class="status" id="lobby-status">初始化中...</div>
        <button id="find-match-btn" onclick="findMatch()">尋找對戰</button>
    </div>
    <div class="panel" id="game-over-panel" style="display: none;">
        <h1 id="end-title">GAME OVER</h1>
        <p id="end-reason">...</p>
        <button onclick="location.reload()">返回大廳</button>
    </div>
</div>

<div id="hp-bar">
    <div>我方: <span id="my-hp">❤️❤️❤️❤️❤️</span></div>
    <div style="font-size: 18px; color: #aaa; margin-top:5px;">敵方: <span id="enemy-hp">❤️❤️❤️❤️❤️</span></div>
    <div id="role-debug" style="font-size: 14px; color: #aaa; margin-top: 5px;"></div>
</div>

<div id="settings-panel">
    <button class="btn-sm active" id="btn-mirror" onclick="toggleMirror()">鏡像: 開</button>
    <button class="btn-sm" id="btn-invert" onclick="toggleInvert()">反向: 關</button>
    <select class="btn-sm" onchange="changeStyle(this.value)" style="background: rgba(0,0,0,0.8);">
        <option value="standard">風格: 標準</option>
        <option value="cyber">風格: 賽博</option>
        <option value="toon">風格: 卡通</option>
    </select>
</div>

<video class="input_video"></video>
<canvas id="output_canvas" width="640" height="480"></canvas>
<div id="canvas-container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"></script>

<script>
    window.findMatch = function() { alert("系統載入中，請稍候..."); };
    window.gameInterface = {
        onGameStart: (role) => console.log("Waiting...", role),
        onRemoteUpdate: (state) => {},
        onRemoteFire: () => {},
        onGameOver: (win) => {}
    };
</script>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
    import { getFirestore, collection, doc, setDoc, updateDoc, onSnapshot, getDocs, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyAwgF1STeKUpjKU87cvS3cJqoHUp8mt_-8",
      authDomain: "tank-94148.firebaseapp.com",
      projectId: "tank-94148",
      storageBucket: "tank-94148.firebasestorage.app",
      messagingSenderId: "433724180176",
      appId: "1:433724180176:web:008f2c3ebbea287aed00d5",
      measurementId: "G-C2SGZJQKCY"
    };

    let app, auth, db;
    try {
        app = initializeApp(firebaseConfig);
        auth = getAuth(app);
        db = getFirestore(app);
        document.getElementById('lobby-status').innerText = "連線成功，請開始對戰";
    } catch (e) {
        document.getElementById('lobby-status').innerText = "系統錯誤: " + e.message;
    }

    let userId = null;
    let matchId = null;
    let myRole = null; 
    let lastNetworkUpdate = 0;

    window.findMatch = async function() {
        const btn = document.getElementById('find-match-btn');
        const status = document.getElementById('lobby-status');
        btn.disabled = true;
        status.innerText = "正在連線伺服器...";

        try {
            const userCredential = await signInAnonymously(auth);
            userId = userCredential.user.uid;
            status.innerText = "搜尋對戰中...";

            const battlesRef = collection(db, 'matches'); 
            const snapshot = await getDocs(battlesRef);
            let foundRoom = null;

            snapshot.forEach(doc => {
                const data = doc.data();
                const now = Date.now();
                const created = data.createdAt ? data.createdAt.toMillis() : 0;
                if (data.status === 'waiting' && (now - created < 3600000) && !foundRoom) {
                    foundRoom = doc.id;
                }
            });

            if (foundRoom) {
                matchId = foundRoom;
                myRole = 'p2';
                status.innerText = "找到房間！正在加入...";
                const matchRef = doc(db, 'matches', matchId);
                await updateDoc(matchRef, {
                    status: 'playing',
                    p2Id: userId,
                    p2State: JSON.stringify({x:0,y:0,z:0,ry:0,ty:0,bx:0,hp:5}),
                    updatedAt: serverTimestamp()
                });
            } else {
                myRole = 'p1';
                status.innerText = "建立房間中，等待挑戰者...";
                const newMatchRef = doc(collection(db, 'matches'));
                matchId = newMatchRef.id;
                await setDoc(newMatchRef, {
                    status: 'waiting',
                    createdAt: serverTimestamp(),
                    p1Id: userId,
                    p1State: JSON.stringify({x:0,y:0,z:0,ry:0,ty:0,bx:0,hp:5}),
                    p2State: JSON.stringify({x:0,y:0,z:0,ry:0,ty:0,bx:0,hp:5}),
                    events: []
                });
            }
            
            window.gameState.myRole = myRole;
            listenToMatch();

        } catch (e) {
            console.error(e);
            status.innerText = "連線錯誤: " + e.message;
            btn.disabled = false;
        }
    };

    function listenToMatch() {
        const matchRef = doc(db, 'matches', matchId);
        const statusEl = document.getElementById('lobby-status');

        onSnapshot(matchRef, (docSnap) => {
            if (!docSnap.exists()) return;
            const data = docSnap.data();

            if (myRole === 'p1' && data.status === 'waiting') {
                statusEl.innerText = "等待對手加入...";
                window.gameInterface.onGameStart('p1_waiting');
            } else if (data.status === 'playing') {
                window.gameInterface.onGameStart(myRole);
                const remoteRole = myRole === 'p1' ? 'p2' : 'p1';
                const remoteStateStr = data[remoteRole + 'State'];
                if (remoteStateStr) {
                    window.gameInterface.onRemoteUpdate(JSON.parse(remoteStateStr));
                }
            } else if (data.status === 'finished') {
                window.gameInterface.onGameOver(data.winner === myRole);
            }

            const remoteRole = myRole === 'p1' ? 'p2' : 'p1';
            const fireKey = `lastFire${remoteRole}`;
            if (data[fireKey] && data[fireKey] > window.gameState.lastRemoteFireTimestamp) {
                window.gameState.lastRemoteFireTimestamp = data[fireKey];
                window.gameInterface.onRemoteFire();
            }
        });
    }

    window.networkLayer = {
        sendState: async (stateObj) => {
            if (!matchId || !myRole) return;
            const now = Date.now();
            if (now - lastNetworkUpdate < 50) return;
            lastNetworkUpdate = now;
            const updateData = {};
            updateData[myRole + 'State'] = JSON.stringify(stateObj);
            try { await updateDoc(doc(db, 'matches', matchId), updateData); } catch(e){}
        },
        sendFire: async () => {
            if (!matchId) return;
            const updateData = {};
            updateData[`lastFire${myRole}`] = Date.now();
            try { await updateDoc(doc(db, 'matches', matchId), updateData); } catch(e){}
        },
        sendHit: async () => {
            if (!matchId) return;
            if (window.gameState.myHP <= 0) {
                await updateDoc(doc(db, 'matches', matchId), {
                    status: 'finished',
                    winner: myRole === 'p1' ? 'p2' : 'p1'
                });
            }
        }
    };
</script>

<script>
    const CONFIG = { smooth: 0.15, aimSmooth: 0.02, sensitivity: 2.5, deadzone: 0.1, fireCD: 500 }; 
    const MAP_SIZE = 150; 
    const BOUNDS = MAP_SIZE / 2 - 2;

    window.gameState = { 
        running: false, myHP: 5, enemyHP: 5, 
        mirrored: true, inverted: false, style: 'standard',
        lastFire: 0, lastRemoteFireTimestamp: 0, myRole: null,
        positionSet: false // 標記是否已強制設定初始位置
    };

    const input = { move: {x:0, y:0}, aim: {x:0, y:0}, head: {x:0} };
    const target = { move: {x:0, y:0}, aim: {x:0, y:0}, head: {x:0} };
    
    let scene, camera, renderer;
    let myTank, myTurret, myBarrel;
    let enemyTank, enemyTurret, enemyBarrel;
    let bullets = [], obstacles = [];
    const clock = new THREE.Clock();

    window.gameInterface.onGameStart = function(role) {
        document.getElementById('ui-layer').style.display = 'none';
        window.gameState.running = true;
        window.gameState.myRole = role;
        
        // 更新 UI
        document.getElementById('role-debug').innerText = role === 'p1_waiting' ? "我是 P1 (等待中)" : `我是 ${role.toUpperCase()}`;
        
        // 強制重設位置 (解決重疊問題)
        if (myTank && enemyTank) {
            if (role.startsWith('p1')) {
                myTank.position.set(0, 0, 60);
                myTank.rotation.y = Math.PI;
                enemyTank.position.set(0, 0, -60);
                enemyTank.rotation.y = 0;
            } else if (role === 'p2') {
                myTank.position.set(0, 0, -60);
                myTank.rotation.y = 0;
                enemyTank.position.set(0, 0, 60);
                enemyTank.rotation.y = Math.PI;
            }
            window.gameState.positionSet = true;
        }
    };

    window.gameInterface.onRemoteUpdate = function(state) {
        if(!enemyTank) return;
        const tPos = new THREE.Vector3(state.x, state.y, state.z);
        enemyTank.position.lerp(tPos, 0.3);
        enemyTank.rotation.y = lerpAngle(enemyTank.rotation.y, state.ry, 0.3);
        enemyTurret.rotation.y = lerpAngle(enemyTurret.rotation.y, state.ty, 0.3);
        enemyBarrel.rotation.x = lerpAngle(enemyBarrel.rotation.x, state.bx, 0.3);
        if(state.hp !== undefined) {
            window.gameState.enemyHP = state.hp;
            updateHPUI();
        }
    };

    window.gameInterface.onRemoteFire = function() {
        if(enemyBarrel) { enemyBarrel.position.z = 1.0; shoot(enemyBarrel, true); }
    };

    window.gameInterface.onGameOver = function(win) {
        window.gameState.running = false;
        document.getElementById('ui-layer').style.display = 'flex';
        document.getElementById('lobby-panel').style.display = 'none';
        document.getElementById('game-over-panel').style.display = 'block';
        document.getElementById('end-title').innerText = win ? "VICTORY" : "DEFEAT";
        document.getElementById('end-title').style.color = win ? "#0f0" : "#f00";
    };

    function initThree() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene(); scene.background = new THREE.Color(0x1a1a1a); scene.fog = new THREE.Fog(0x1a1a1a, 20, 150);
        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 500);
        camera.position.set(0, 20, -30);
        
        renderer = new THREE.WebGLRenderer({antialias:true}); renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffeeb1, 1); light.position.set(20, 50, -20); light.castShadow = true;
        light.shadow.mapSize.width = 2048; light.shadow.mapSize.height = 2048;
        scene.add(light); scene.add(new THREE.AmbientLight(0xffffff, 0.6));

        const plane = new THREE.Mesh(new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE), new THREE.MeshStandardMaterial({color:0x333333, roughness:0.8}));
        plane.rotation.x = -Math.PI/2; plane.receiveShadow = true; plane.userData.type='ground'; scene.add(plane);
        const grid = new THREE.GridHelper(MAP_SIZE, 40, 0x555555, 0x222222); scene.add(grid);
        createWalls();

        const p1 = createModel(0x4B5320, false);
        myTank = p1.root; myTurret = p1.turret; myBarrel = p1.barrel;
        addLaser(myBarrel);
        const marker = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1, 8), new THREE.MeshBasicMaterial({color: 0x00ff00}));
        marker.rotation.x = Math.PI; marker.position.y = 5; myTank.add(marker);
        scene.add(myTank);

        const p2 = createModel(0xAA3333, true);
        enemyTank = p2.root; enemyTurret = p2.turret; enemyBarrel = p2.barrel;
        scene.add(enemyTank);

        changeStyle('standard');
        requestAnimationFrame(animate);
    }

    function createWalls() {
        const h = 4; const geo = new THREE.BoxGeometry(MAP_SIZE, h, 2);
        const mat = new THREE.MeshStandardMaterial({color: 0x00ffff, emissive: 0x004444, transparent: true, opacity: 0.5});
        const pos = [[0, h/2, -MAP_SIZE/2], [0, h/2, MAP_SIZE/2], [-MAP_SIZE/2, h/2, 0, Math.PI/2], [MAP_SIZE/2, h/2, 0, Math.PI/2]];
        pos.forEach(p => { const w = new THREE.Mesh(geo, mat); w.position.set(p[0], p[1], p[2]); if(p[3]) w.rotation.y = p[3]; w.userData.type='wall'; scene.add(w); });
    }

    function createModel(color, isEnemy) {
        const root = new THREE.Group();
        const bodyM = new THREE.MeshStandardMaterial({color:color});
        const chassis = new THREE.Mesh(new THREE.BoxGeometry(4, 1.5, 6), bodyM);
        chassis.position.y = 1.2; chassis.castShadow=true; chassis.userData.type=isEnemy?'eBody':'pBody'; root.add(chassis);
        const tG = new THREE.Group(); tG.position.set(0, 2, 0); root.add(tG);
        const tMesh = new THREE.Mesh(new THREE.BoxGeometry(3, 1.2, 3.5), bodyM);
        tMesh.position.y = 0.6; tMesh.castShadow=true; tMesh.userData.type=isEnemy?'eTurret':'pTurret'; tG.add(tMesh);
        const bG = new THREE.Group(); bG.position.set(0, 0.6, 1.5); tG.add(bG);
        const bMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 5, 16), bodyM);
        bMesh.rotation.x = Math.PI/2; bMesh.position.z = 2.5; bMesh.castShadow=true; bMesh.userData.type=isEnemy?'eBarrel':'pBarrel'; bG.add(bMesh);
        return { root, turret: tG, barrel: bG };
    }

    function addLaser(barrelObj) {
        const laserGeo = new THREE.CylinderGeometry(0.05, 0.05, 100, 8);
        laserGeo.rotateX(-Math.PI / 2); laserGeo.translate(0, 0, 50);
        const laser = new THREE.Mesh(laserGeo, new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.3, blending: THREE.AdditiveBlending }));
        laser.position.set(0, 0, 5); barrelObj.add(laser);
    }

    function shoot(origin, isEnemy) {
        origin.updateMatrixWorld();
        const muzzlePos = new THREE.Vector3(0, 0, 6).applyMatrix4(origin.matrixWorld);
        const quat = new THREE.Quaternion(); origin.getWorldQuaternion(quat);
        const dir = new THREE.Vector3(0, 0, 1).applyQuaternion(quat);
        const bullet = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 4, 8).rotateX(Math.PI/2), new THREE.MeshBasicMaterial({color: isEnemy?0xff3333:0xffff00}));
        bullet.position.copy(muzzlePos); bullet.quaternion.copy(quat);
        bullet.add(new THREE.PointLight(isEnemy?0xff3333:0xffff00, 1, 15));
        bullet.userData = { vel: dir.multiplyScalar(70), life: 3, isEnemy };
        scene.add(bullet); bullets.push(bullet);
        const flash = new THREE.Mesh(new THREE.SphereGeometry(1.5,16,16), new THREE.MeshBasicMaterial({color: isEnemy?0xff8888:0xffffff, transparent:true, opacity:0.9}));
        flash.position.copy(muzzlePos); scene.add(flash);
        let s=1; const anim = ()=>{ s+=0.4; flash.scale.setScalar(s); flash.material.opacity-=0.15; if(flash.material.opacity>0)requestAnimationFrame(anim); else scene.remove(flash);}; anim();
    }

    function lerpAngle(a, b, t) {
        let diff = b - a; while (diff > Math.PI) diff -= Math.PI * 2; while (diff < -Math.PI) diff += Math.PI * 2; return a + diff * t;
    }

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        if(!window.gameState.running) { renderer.render(scene, camera); return; }

        input.move.x += (target.move.x - input.move.x) * CONFIG.moveSmooth;
        input.move.y += (target.move.y - input.move.y) * CONFIG.moveSmooth;
        input.aim.x += (target.aim.x - input.aim.x) * CONFIG.aimSmooth;
        input.head.x += (target.head.x - input.head.x) * 0.1;

        if(myTank) {
            // 移動邏輯 (修復版)
            if(Math.abs(input.move.x)>0.01) myTank.rotation.y -= input.move.x*2*dt;
            // 修正：移動方向需配合車身朝向
            // 因為 myTank 是 Group，使用 translateZ 會沿著目前朝向移動
            if(Math.abs(input.move.y)>0.01) myTank.translateZ(input.move.y*12*dt);
            
            myTank.position.x = Math.max(-BOUNDS, Math.min(BOUNDS, myTank.position.x));
            myTank.position.z = Math.max(-BOUNDS, Math.min(BOUNDS, myTank.position.z));

            const aimSpeed = Math.sign(input.aim.x) * Math.pow(Math.abs(input.aim.x), 1.5) * 1.5;
            myTurret.rotation.y -= aimSpeed * dt;
            myBarrel.rotation.x = 0; 
            
            if(myBarrel.position.z < 1.5) myBarrel.position.z += 5*dt; else myBarrel.position.z = 1.5;
            if(enemyBarrel && enemyBarrel.position.z < 1.5) enemyBarrel.position.z += 5*dt; else if(enemyBarrel) enemyBarrel.position.z = 1.5;

            const camOffsetLocal = new THREE.Vector3(input.head.x * 5, 8, -25 - Math.abs(input.head.x));
            const camTargetPos = camOffsetLocal.applyMatrix4(myTurret.matrixWorld);
            camera.position.lerp(camTargetPos, 0.1);
            const lookAtOffsetLocal = new THREE.Vector3(input.head.x * 2, 0, 50); 
            const lookAtTargetPos = lookAtOffsetLocal.applyMatrix4(myTurret.matrixWorld);
            camera.lookAt(lookAtTargetPos);

            if(window.networkLayer && window.networkLayer.sendState) {
                window.networkLayer.sendState({
                    x: myTank.position.x, y: myTank.position.y, z: myTank.position.z,
                    ry: myTank.rotation.y, ty: myTurret.rotation.y, bx: myBarrel.rotation.x, hp: window.gameState.myHP
                });
            }
        }

        for(let i=bullets.length-1; i>=0; i--) {
            const b = bullets[i];
            b.position.add(b.userData.vel.clone().multiplyScalar(dt));
            b.userData.life -= dt;
            let hit = false;
            if(b.userData.isEnemy) {
                if(b.position.distanceTo(myTank.position) < 3.5) {
                    hit = true; takeDamage(); createExplosion(b.position);
                }
            } else {
                if(enemyTank && b.position.distanceTo(enemyTank.position) < 3.5) {
                    hit = true; createExplosion(b.position);
                }
            }
            if(hit || Math.abs(b.position.x)>BOUNDS || Math.abs(b.position.z)>BOUNDS || b.userData.life<=0) {
                scene.remove(b); bullets.splice(i,1);
            }
        }
        renderer.render(scene, camera);
    }

    function takeDamage() {
        window.gameState.myHP--;
        updateHPUI();
        document.getElementById('damage-overlay').style.opacity = 0.5; 
        setTimeout(()=>document.getElementById('damage-overlay').style.opacity=0, 200);
        if(window.networkLayer && window.networkLayer.sendHit) window.networkLayer.sendHit();
    }

    function updateHPUI() {
        document.getElementById('my-hp').innerText = "❤️".repeat(Math.max(0, window.gameState.myHP));
        document.getElementById('enemy-hp').innerText = "❤️".repeat(Math.max(0, window.gameState.enemyHP));
    }

    window.changeStyle = function(s) {
        window.gameState.style = s;
        const colors = { standard: [0x1a1a1a, 0x4B5320, 0xAA3333], cyber: [0x000000, 0x00ff00, 0xff0000], toon: [0x87CEEB, 0x228B22, 0xFF4500] };
        const c = colors[s];
        scene.background = new THREE.Color(c[0]); scene.fog.color.setHex(c[0]);
        scene.traverse(o => {
            if(o.isMesh && o.userData.type) {
                let col = 0x888888;
                if(o.userData.type.includes('p')) col = c[1];
                else if(o.userData.type.includes('e')) col = c[2];
                else if(o.userData.type==='ground') col = s==='cyber'?0x000000:(s==='toon'?0x7CFC00:0x333333);
                else if(o.userData.type==='wall') col = s==='cyber'?0x00ff00:0x00ffff;
                o.material = s==='toon' ? new THREE.MeshToonMaterial({color:col}) : (s==='cyber'? new THREE.MeshBasicMaterial({color:col, wireframe:true}) : (o.userData.type==='wall'?o.material:new THREE.MeshStandardMaterial({color:col})));
            }
        });
    }
    window.toggleMirror = function() { window.gameState.mirrored=!window.gameState.mirrored; document.getElementById('btn-mirror').innerText = window.gameState.mirrored?"鏡像: 開":"鏡像: 關"; document.getElementById('output_canvas').style.transform = window.gameState.mirrored?"scaleX(-1)":"none"; document.getElementById('btn-mirror').classList.toggle('active'); }
    window.toggleInvert = function() { window.gameState.inverted=!window.gameState.inverted; document.getElementById('btn-invert').innerText = window.gameState.inverted?"反向: 開":"反向: 關"; document.getElementById('btn-invert').classList.toggle('active'); }

    initThree();

    const canvas = document.getElementById('output_canvas'), ctx = canvas.getContext('2d');
    const holistic = new Holistic({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${f}`});
    holistic.setOptions({modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
    holistic.onResults(res => {
        document.getElementById('debug-info').innerText = "AI 運作中 | L-Hand: " + (res.leftHandLandmarks?"Yes":"No") + " | Pose: " + (res.poseLandmarks?"Yes":"No");
        
        ctx.clearRect(0,0,640,480);
        if(res.image) { ctx.globalAlpha=0.5; ctx.drawImage(res.image,0,0,640,480); ctx.globalAlpha=1; }
        drawJoy(0.25, 0.6, "移動 (左手)", target.move); drawJoy(0.75, 0.6, "瞄準 (右手)", target.aim);
        drawCooldown(0.75, 0.6, window.gameState.lastFire, CONFIG.fireCD);

        // --- 核心修復：雙重偵測移動 ---
        // 優先使用手部模型，若無則使用身體 Pose 模型 (手腕)
        let moveX = 0, moveY = 0;
        let detected = false;

        if(res.leftHandLandmarks) {
            drawHand(res.leftHandLandmarks);
            moveX = (res.leftHandLandmarks[9].x - 0.25)*-2.5;
            moveY = (res.leftHandLandmarks[9].y - 0.6)*-2.5;
            detected = true;
        } else if (res.poseLandmarks) {
            // 使用 Pose Landmark 19 (左食指) 或 15 (左手腕)
            const wrist = res.poseLandmarks[15]; // Left Wrist
            if (wrist && wrist.visibility > 0.5) {
                // 繪製一個替代點
                ctx.beginPath(); ctx.arc(wrist.x*640, wrist.y*480, 10, 0, 7); ctx.fillStyle="yellow"; ctx.fill();
                moveX = (wrist.x - 0.25)*-2.5;
                moveY = (wrist.y - 0.6)*-2.5;
                detected = true;
            }
        }

        if (detected) {
            if(window.gameState.inverted) moveX *= -1;
            target.move = { x: clamp(moveX), y: clamp(moveY) };
            drawJoyStick(0.25, 0.6, target.move.x, target.move.y, true);
        } else {
            target.move = {x:0, y:0};
        }
        
        if(res.rightHandLandmarks) {
            drawHand(res.rightHandLandmarks);
            target.aim = { x: clamp((res.rightHandLandmarks[9].x - 0.75)*-2.5), y: 0 };
            const pinch = Math.hypot(res.rightHandLandmarks[4].x - res.rightHandLandmarks[6].x, res.rightHandLandmarks[4].y - res.rightHandLandmarks[6].y) < 0.05;
            const now = Date.now();
            if(pinch && now - window.gameState.lastFire > CONFIG.fireCD && window.gameState.running) { 
                window.gameState.lastFire = now; 
                if(myBarrel) myBarrel.position.z = 1.0; 
                shoot(myBarrel, false); 
                if(window.networkLayer && window.networkLayer.sendFire) window.networkLayer.sendFire();
            }
            drawJoyStick(0.75, 0.6, target.aim.x, target.aim.y, pinch);
        } else target.aim = {x:0, y:0};
        
        target.head.x = res.faceLandmarks ? (res.faceLandmarks[1].x - 0.5)*(window.gameState.mirrored?-3:3) : 0;
    });

    const cam = new Camera(document.querySelector('.input_video'), { onFrame: async()=>{ await holistic.send({image:document.querySelector('.input_video')})}, width:640, height:480 });
    cam.start();

    function clamp(v) { return Math.max(-1, Math.min(1, Math.abs(v)<CONFIG.deadzone ? 0 : (v>0?v-CONFIG.deadzone:v+CONFIG.deadzone)/(1-CONFIG.deadzone))); }
    function drawJoy(nx, ny, txt) { 
        const x=nx*640, y=ny*480; 
        ctx.beginPath(); ctx.arc(x,y,40,0,7); ctx.strokeStyle="#fff5"; ctx.stroke();
        ctx.fillStyle="#0ff"; ctx.font="16px Arial"; ctx.textAlign="center"; 
        ctx.save(); ctx.translate(x,y); if(window.gameState.mirrored) ctx.scale(-1,1); ctx.fillText(txt,0,60); ctx.restore();
    }
    function drawCooldown(nx, ny, last, cd) {
        const x=nx*640, y=ny*480; const progress = Math.min(1, (Date.now() - last) / cd);
        if(progress < 1) { ctx.beginPath(); ctx.arc(x, y, 50, -Math.PI/2, -Math.PI/2 + Math.PI*2*progress); ctx.strokeStyle = "#ff0000"; ctx.lineWidth = 5; ctx.stroke(); } 
        else { ctx.beginPath(); ctx.arc(x, y, 50, 0, Math.PI*2); ctx.strokeStyle = "#00ff00"; ctx.lineWidth = 2; ctx.stroke(); }
    }
    function drawJoyStick(nx, ny, dx, dy, act) {
        const cx=nx*640, cy=ny*480, tx=cx-dx*40, ty=cy-dy*40;
        ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(tx,ty); ctx.strokeStyle=act?"#f00":"#0f0"; ctx.lineWidth=3; ctx.stroke();
        ctx.beginPath(); ctx.arc(tx,ty,10,0,7); ctx.fillStyle=act?"#f00":"#0f0"; ctx.fill();
    }
    function drawHand(lm) { drawConnectors(ctx, lm, HAND_CONNECTIONS, {color:'#0f0', lineWidth:1}); drawLandmarks(ctx, lm, {color:'#f00', radius:2}); }
</script>
</body>
</html>
